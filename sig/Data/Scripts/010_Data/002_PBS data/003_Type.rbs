# TypeProf 0.21.3

# Classes
module GameData
  class Type
    type schema = {
        :id => Symbol,
        :real_name => String,
        :icon_position => Integer,
    :special_type => bool,
    :pseudo_type => bool,
    :weaknesses => Symbol | Array[Symbol],
    :resistances => Symbol | Array[Symbol],
    :immunities => Symbol | Array[Symbol],
    :flags => Array[String],
    :pbs_file_suffix => String,
        }
    DATA: Hash[Symbol, Type]
    DATA_FILENAME: String
    PBS_BASE_FILENAME: String
    SCHEMA: Hash[String, [Symbol, String]]

    extend ClassMethodsSymbols[schema]
    include InstanceMethods

    attr_reader id: Symbol
    attr_reader real_name: String
    attr_reader icon_position: Integer
    attr_reader special_type: bool
    attr_reader pseudo_type: bool
    attr_reader weaknesses: Array[Symbol]
    attr_reader resistances: Array[Symbol]
    attr_reader immunities: Array[Symbol]
    attr_reader flags: Array[String]
    attr_reader pbs_file_suffix: String
    def initialize: (schema hash) -> void
    def name: -> String
    def physical?: -> bool
    def special?: -> bool
    def has_flag?: (String flag) -> bool
    def effectiveness: (untyped other_type) -> Integer
  end
end

module Effectiveness
  INEFFECTIVE: Integer
  NOT_VERY_EFFECTIVE: Integer
  NORMAL_EFFECTIVE: Integer
  SUPER_EFFECTIVE: Integer
  INEFFECTIVE_MULTIPLIER: Float
  NOT_VERY_EFFECTIVE_MULTIPLIER: Float
  NORMAL_EFFECTIVE_MULTIPLIER: Float
  SUPER_EFFECTIVE_MULTIPLIER: Float

  def ineffective?: (Complex | Float value) -> bool
  def self.ineffective?: (Complex | Float value) -> bool
  def not_very_effective?: (Complex | Float value) -> bool
  def self.not_very_effective?: (Complex | Float value) -> bool
  def resistant?: (Complex | Float value) -> bool
  def self.resistant?: (Complex | Float value) -> bool
  def normal?: (Complex | Float value) -> bool
  def self.normal?: (Complex | Float value) -> bool
  def super_effective?: (Complex | Float value) -> bool
  def self.super_effective?: (Complex | Float value) -> bool
  def ineffective_type?: (untyped attack_type, *untyped defend_types) -> bool
  def self.ineffective_type?: (untyped attack_type, *untyped defend_types) -> bool
  def not_very_effective_type?: (untyped attack_type, *untyped defend_types) -> bool
  def self.not_very_effective_type?: (untyped attack_type, *untyped defend_types) -> bool
  def resistant_type?: (untyped attack_type, *untyped defend_types) -> bool
  def self.resistant_type?: (untyped attack_type, *untyped defend_types) -> bool
  def normal_type?: (untyped attack_type, *untyped defend_types) -> bool
  def self.normal_type?: (untyped attack_type, *untyped defend_types) -> bool
  def super_effective_type?: (untyped attack_type, *untyped defend_types) -> bool
  def self.super_effective_type?: (untyped attack_type, *untyped defend_types) -> bool
  def get_type_effectiveness: (untyped attack_type, untyped defend_type) -> untyped
  def self.get_type_effectiveness: (untyped attack_type, untyped defend_type) -> untyped
  def calculate: (untyped attack_type, *untyped defend_types) -> (Complex | Float)
  def self.calculate: (untyped attack_type, *untyped defend_types) -> (Complex | Float)
end


